# The minMalwareSpread method identifies the node that, when removed, minimizes malware spread.

# Approach:
# - Use DFS to group nodes into components and count their sizes.
# - Track how many initially infected nodes belong to each component.
# - If a component has only one infected node, removing it reduces spread the most.
# - Return the node that achieves the largest reduction or the smallest index if tied.

# TC: O(n^2) - DFS traversal for all nodes in the graph.
# SC: O(n) - Space for components and tracking data.


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        node_components = {}
        component_counts = {}
        component_initials = defaultdict(int)
        component = 0
        initial.sort()
        for init in initial:
            prior_count = len(node_components)
            self.dfs(graph, init, node_components, component)
            diff_count = len(node_components) - prior_count
            if diff_count > 0:
                component_counts[component] = diff_count
                component_initials[component] += 1
                component += 1
            else:
                init_component = node_components[init]
                component_initials[init_component] += 1

        res_node, res_count = initial[0], -1
        for init in initial:
            init_component = node_components[init]
            if component_initials[init_component] == 1:
                cur_count = component_counts[init_component]
                if cur_count > res_count:
                    res_node, res_count = init, cur_count
        
        return res_node

    def dfs(self, graph, node, node_components, component):
        if node in node_components:
            return
        node_components[node] = component
        for nei in range(len(graph)):
            if graph[node][nei] == 1:
                self.dfs(graph, nei, node_components, component)